// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: packet.proto

#include "stms/proto/packet.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

namespace stms {
    namespace proto {
        class PacketDefaultTypeInternal {
        public:
            ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Packet> _instance;
        } _Packet_default_instance_;
    }  // namespace proto
}  // namespace stms
static void InitDefaultsscc_info_Packet_packet_2eproto() {
    GOOGLE_PROTOBUF_VERIFY_VERSION;

    {
        void *ptr = &::stms::proto::_Packet_default_instance_;
        new(ptr) ::stms::proto::Packet();
        ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
    }
    ::stms::proto::Packet::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Packet_packet_2eproto =
        {{ATOMIC_VAR_INIT(
                  ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Packet_packet_2eproto},
         {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_packet_2eproto[1];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *file_level_enum_descriptors_packet_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const **file_level_service_descriptors_packet_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_packet_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
        protodesc_cold) = {
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::stms::proto::Packet, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::stms::proto::Packet, flags_),
        PROTOBUF_FIELD_OFFSET(::stms::proto::Packet, sequencenumber_),
        PROTOBUF_FIELD_OFFSET(::stms::proto::Packet, data_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, -1, sizeof(::stms::proto::Packet)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const *const file_default_instances[] = {
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message *>(&::stms::proto::_Packet_default_instance_),
};

const char descriptor_table_protodef_packet_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
        "\n\014packet.proto\022\nstms.proto\"\204\001\n\006Packet\022\r\n"
        "\005flags\030\001 \001(\r\022\026\n\016sequenceNumber\030\002 \001(\004\022\014\n\004"
        "data\030\003 \001(\014\"E\n\005Flags\022\016\n\neDoNotDrop\020\000\022\021\n\re"
        "DoNotReorder\020\001\022\r\n\teDoReplay\020\002\022\n\n\006eIsACK\020"
        "\003b\006proto3";
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable *const descriptor_table_packet_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase *const descriptor_table_packet_2eproto_sccs[1] = {
        &scc_info_Packet_packet_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_packet_2eproto_once;
static bool descriptor_table_packet_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_packet_2eproto = {
        &descriptor_table_packet_2eproto_initialized, descriptor_table_protodef_packet_2eproto, "packet.proto", 169,
        &descriptor_table_packet_2eproto_once, descriptor_table_packet_2eproto_sccs,
        descriptor_table_packet_2eproto_deps, 1, 0,
        schemas, file_default_instances, TableStruct_packet_2eproto::offsets,
        file_level_metadata_packet_2eproto, 1, file_level_enum_descriptors_packet_2eproto,
        file_level_service_descriptors_packet_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_packet_2eproto = (::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(
        &descriptor_table_packet_2eproto), true);
namespace stms {
    namespace proto {
        const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *Packet_Flags_descriptor() {
            ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_packet_2eproto);
            return file_level_enum_descriptors_packet_2eproto[0];
        }

        bool Packet_Flags_IsValid(int value) {
            switch (value) {
                case 0:
                case 1:
                case 2:
                case 3:
                    return true;
                default:
                    return false;
            }
        }

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
        constexpr Packet_Flags Packet::eDoNotDrop;
        constexpr Packet_Flags Packet::eDoNotReorder;
        constexpr Packet_Flags Packet::eDoReplay;
        constexpr Packet_Flags Packet::eIsACK;
        constexpr Packet_Flags Packet::Flags_MIN;
        constexpr Packet_Flags Packet::Flags_MAX;
        constexpr int Packet::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

        void Packet::InitAsDefaultInstance() {
        }

        class Packet::_Internal {
        public:
        };

        Packet::Packet()
                : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
            SharedCtor();
            // @@protoc_insertion_point(constructor:stms.proto.Packet)
        }

        Packet::Packet(const Packet &from)
                : ::PROTOBUF_NAMESPACE_ID::Message(),
                  _internal_metadata_(nullptr) {
            _internal_metadata_.MergeFrom(from._internal_metadata_);
            data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
            if (!from._internal_data().empty()) {
                data_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.data_);
            }
            ::memcpy(&sequencenumber_, &from.sequencenumber_,
                     static_cast<size_t>(reinterpret_cast<char *>(&flags_) -
                                         reinterpret_cast<char *>(&sequencenumber_)) + sizeof(flags_));
            // @@protoc_insertion_point(copy_constructor:stms.proto.Packet)
        }

        void Packet::SharedCtor() {
            ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Packet_packet_2eproto.base);
            data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
            ::memset(&sequencenumber_, 0, static_cast<size_t>(
                                                  reinterpret_cast<char *>(&flags_) -
                                                  reinterpret_cast<char *>(&sequencenumber_)) + sizeof(flags_));
        }

        Packet::~Packet() {
            // @@protoc_insertion_point(destructor:stms.proto.Packet)
            SharedDtor();
        }

        void Packet::SharedDtor() {
            data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        }

        void Packet::SetCachedSize(int size) const {
            _cached_size_.Set(size);
        }

        const Packet &Packet::default_instance() {
            ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Packet_packet_2eproto.base);
            return *internal_default_instance();
        }


        void Packet::Clear() {
// @@protoc_insertion_point(message_clear_start:stms.proto.Packet)
            ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
            // Prevent compiler warnings about cached_has_bits being unused
            (void) cached_has_bits;

            data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
            ::memset(&sequencenumber_, 0, static_cast<size_t>(
                                                  reinterpret_cast<char *>(&flags_) -
                                                  reinterpret_cast<char *>(&sequencenumber_)) + sizeof(flags_));
            _internal_metadata_.Clear();
        }

        const char *Packet::_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
            while (!ctx->Done(&ptr)) {
                ::PROTOBUF_NAMESPACE_ID::uint32 tag;
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
                CHK_(ptr);
                switch (tag >> 3) {
                    // uint32 flags = 1;
                    case 1:
                        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
                            flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                            CHK_(ptr);
                        } else goto handle_unusual;
                        continue;
                        // uint64 sequenceNumber = 2;
                    case 2:
                        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
                            sequencenumber_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
                            CHK_(ptr);
                        } else goto handle_unusual;
                        continue;
                        // bytes data = 3;
                    case 3:
                        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
                            auto str = _internal_mutable_data();
                            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
                            CHK_(ptr);
                        } else goto handle_unusual;
                        continue;
                    default: {
                        handle_unusual:
                        if ((tag & 7) == 4 || tag == 0) {
                            ctx->SetLastTag(tag);
                            goto success;
                        }
                        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
                        CHK_(ptr != nullptr);
                        continue;
                    }
                }  // switch
            }  // while
            success:
            return ptr;
            failure:
            ptr = nullptr;
            goto success;
#undef CHK_
        }

        ::PROTOBUF_NAMESPACE_ID::uint8 *Packet::_InternalSerialize(
                ::PROTOBUF_NAMESPACE_ID::uint8 *target,
                ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const {
            // @@protoc_insertion_point(serialize_to_array_start:stms.proto.Packet)
            ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
            (void) cached_has_bits;

            // uint32 flags = 1;
            if (this->flags() != 0) {
                target = stream->EnsureSpace(target);
                target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1,
                                                                                               this->_internal_flags(),
                                                                                               target);
            }

            // uint64 sequenceNumber = 2;
            if (this->sequencenumber() != 0) {
                target = stream->EnsureSpace(target);
                target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2,
                                                                                               this->_internal_sequencenumber(),
                                                                                               target);
            }

            // bytes data = 3;
            if (this->data().size() > 0) {
                target = stream->WriteBytesMaybeAliased(
                        3, this->_internal_data(), target);
            }

            if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
                target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                        _internal_metadata_.unknown_fields(), target, stream);
            }
            // @@protoc_insertion_point(serialize_to_array_end:stms.proto.Packet)
            return target;
        }

        size_t Packet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:stms.proto.Packet)
            size_t total_size = 0;

            ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
            // Prevent compiler warnings about cached_has_bits being unused
            (void) cached_has_bits;

            // bytes data = 3;
            if (this->data().size() > 0) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                      this->_internal_data());
            }

            // uint64 sequenceNumber = 2;
            if (this->sequencenumber() != 0) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                                      this->_internal_sequencenumber());
            }

            // uint32 flags = 1;
            if (this->flags() != 0) {
                total_size += 1 +
                              ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                                      this->_internal_flags());
            }

            if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
                return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                        _internal_metadata_, total_size, &_cached_size_);
            }
            int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
            SetCachedSize(cached_size);
            return total_size;
        }

        void Packet::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) {
// @@protoc_insertion_point(generalized_merge_from_start:stms.proto.Packet)
                    GOOGLE_DCHECK_NE(&from, this);
            const Packet *source =
                    ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Packet>(
                            &from);
            if (source == nullptr) {
                // @@protoc_insertion_point(generalized_merge_from_cast_fail:stms.proto.Packet)
                ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
            } else {
                // @@protoc_insertion_point(generalized_merge_from_cast_success:stms.proto.Packet)
                MergeFrom(*source);
            }
        }

        void Packet::MergeFrom(const Packet &from) {
// @@protoc_insertion_point(class_specific_merge_from_start:stms.proto.Packet)
                    GOOGLE_DCHECK_NE(&from, this);
            _internal_metadata_.MergeFrom(from._internal_metadata_);
            ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
            (void) cached_has_bits;

            if (from.data().size() > 0) {

                data_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.data_);
            }
            if (from.sequencenumber() != 0) {
                _internal_set_sequencenumber(from._internal_sequencenumber());
            }
            if (from.flags() != 0) {
                _internal_set_flags(from._internal_flags());
            }
        }

        void Packet::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) {
// @@protoc_insertion_point(generalized_copy_from_start:stms.proto.Packet)
            if (&from == this) return;
            Clear();
            MergeFrom(from);
        }

        void Packet::CopyFrom(const Packet &from) {
// @@protoc_insertion_point(class_specific_copy_from_start:stms.proto.Packet)
            if (&from == this) return;
            Clear();
            MergeFrom(from);
        }

        bool Packet::IsInitialized() const {
            return true;
        }

        void Packet::InternalSwap(Packet *other) {
            using std::swap;
            _internal_metadata_.Swap(&other->_internal_metadata_);
            data_.Swap(&other->data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                       GetArenaNoVirtual());
            swap(sequencenumber_, other->sequencenumber_);
            swap(flags_, other->flags_);
        }

        ::PROTOBUF_NAMESPACE_ID::Metadata Packet::GetMetadata() const {
            return GetMetadataStatic();
        }


// @@protoc_insertion_point(namespace_scope)
    }  // namespace proto
}  // namespace stms
PROTOBUF_NAMESPACE_OPEN
        template<>
        PROTOBUF_NOINLINE ::stms::proto::Packet *Arena::CreateMaybeMessage<::stms::proto::Packet>(Arena *arena) {
            return Arena::CreateInternal<::stms::proto::Packet>(arena);
        }
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
