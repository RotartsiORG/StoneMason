// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: packet.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_packet_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_packet_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>

#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

#define PROTOBUF_INTERNAL_EXPORT_packet_2eproto
PROTOBUF_NAMESPACE_OPEN
        namespace internal {
            class AnyMetadata;
        }  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_packet_2eproto {
    static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
    static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
    static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_packet_2eproto;
namespace stms {
    namespace proto {
        class Packet;

        class PacketDefaultTypeInternal;

        extern PacketDefaultTypeInternal _Packet_default_instance_;
    }  // namespace proto
}  // namespace stms
PROTOBUF_NAMESPACE_OPEN
        template<>
        ::stms::proto::Packet *Arena::CreateMaybeMessage<::stms::proto::Packet>(Arena *);
PROTOBUF_NAMESPACE_CLOSE
namespace stms {
    namespace proto {

        enum Packet_Flags : int {
            Packet_Flags_eDoNotDrop = 0,
            Packet_Flags_eDoNotReorder = 1,
            Packet_Flags_eDoReplay = 2,
            Packet_Flags_eIsACK = 3,
            Packet_Flags_Packet_Flags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
            Packet_Flags_Packet_Flags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
        };

        bool Packet_Flags_IsValid(int value);

        constexpr Packet_Flags Packet_Flags_Flags_MIN = Packet_Flags_eDoNotDrop;
        constexpr Packet_Flags Packet_Flags_Flags_MAX = Packet_Flags_eIsACK;
        constexpr int Packet_Flags_Flags_ARRAYSIZE = Packet_Flags_Flags_MAX + 1;

        const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *Packet_Flags_descriptor();

        template<typename T>
        inline const std::string &Packet_Flags_Name(T enum_t_value) {
            static_assert(::std::is_same<T, Packet_Flags>::value ||
                          ::std::is_integral<T>::value,
                          "Incorrect type passed to function Packet_Flags_Name.");
            return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
                    Packet_Flags_descriptor(), enum_t_value);
        }

        inline bool Packet_Flags_Parse(
                const std::string &name, Packet_Flags *value) {
            return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Packet_Flags>(
                    Packet_Flags_descriptor(), name, value);
        }
// ===================================================================

        class Packet :
                public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stms.proto.Packet) */ {
        public:
            Packet();

            virtual ~Packet();

            Packet(const Packet &from);

            Packet(Packet &&from) noexcept
                    : Packet() {
                *this = ::std::move(from);
            }

            inline Packet &operator=(const Packet &from) {
                CopyFrom(from);
                return *this;
            }

            inline Packet &operator=(Packet &&from) noexcept {
                if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
                    if (this != &from) InternalSwap(&from);
                } else {
                    CopyFrom(from);
                }
                return *this;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                return GetDescriptor();
            }

            static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                return GetMetadataStatic().descriptor;
            }

            static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                return GetMetadataStatic().reflection;
            }

            static const Packet &default_instance();

            static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
            static inline const Packet *internal_default_instance() {
                return reinterpret_cast<const Packet *>(
                        &_Packet_default_instance_);
            }

            static constexpr int kIndexInFileMessages =
                    0;

            friend void swap(Packet &a, Packet &b) {
                a.Swap(&b);
            }

            inline void Swap(Packet *other) {
                if (other == this) return;
                InternalSwap(other);
            }

            // implements Message ----------------------------------------------

            inline Packet *New() const final {
                return CreateMaybeMessage<Packet>(nullptr);
            }

            Packet *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                return CreateMaybeMessage<Packet>(arena);
            }

            void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

            void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

            void CopyFrom(const Packet &from);

            void MergeFrom(const Packet &from);

            PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;

            bool IsInitialized() const final;

            size_t ByteSizeLong() const final;

            const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;

            ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
                    ::PROTOBUF_NAMESPACE_ID::uint8 *target,
                    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

            int GetCachedSize() const final { return _cached_size_.Get(); }

        private:
            inline void SharedCtor();

            inline void SharedDtor();

            void SetCachedSize(int size) const final;

            void InternalSwap(Packet *other);

            friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

            static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                return "stms.proto.Packet";
            }

        private:
            inline ::PROTOBUF_NAMESPACE_ID::Arena *GetArenaNoVirtual() const {
                return nullptr;
            }

            inline void *MaybeArenaPtr() const {
                return nullptr;
            }

        public:

            ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

        private:
            static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
                ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packet_2eproto);
                return ::descriptor_table_packet_2eproto.file_level_metadata[kIndexInFileMessages];
            }

        public:

            // nested types ----------------------------------------------------

            typedef Packet_Flags Flags;
            static constexpr Flags eDoNotDrop =
                    Packet_Flags_eDoNotDrop;
            static constexpr Flags eDoNotReorder =
                    Packet_Flags_eDoNotReorder;
            static constexpr Flags eDoReplay =
                    Packet_Flags_eDoReplay;
            static constexpr Flags eIsACK =
                    Packet_Flags_eIsACK;

            static inline bool Flags_IsValid(int value) {
                return Packet_Flags_IsValid(value);
            }

            static constexpr Flags Flags_MIN =
                    Packet_Flags_Flags_MIN;
            static constexpr Flags Flags_MAX =
                    Packet_Flags_Flags_MAX;
            static constexpr int Flags_ARRAYSIZE =
                    Packet_Flags_Flags_ARRAYSIZE;

            static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *
            Flags_descriptor() {
                return Packet_Flags_descriptor();
            }

            template<typename T>
            static inline const std::string &Flags_Name(T enum_t_value) {
                static_assert(::std::is_same<T, Flags>::value ||
                              ::std::is_integral<T>::value,
                              "Incorrect type passed to function Flags_Name.");
                return Packet_Flags_Name(enum_t_value);
            }

            static inline bool Flags_Parse(const std::string &name,
                                           Flags *value) {
                return Packet_Flags_Parse(name, value);
            }

            // accessors -------------------------------------------------------

            enum : int {
                kDataFieldNumber = 3,
                kSequenceNumberFieldNumber = 2,
                kFlagsFieldNumber = 1,
            };

            // bytes data = 3;
            void clear_data();

            const std::string &data() const;

            void set_data(const std::string &value);

            void set_data(std::string &&value);

            void set_data(const char *value);

            void set_data(const void *value, size_t size);

            std::string *mutable_data();

            std::string *release_data();

            void set_allocated_data(std::string *data);

        private:
            const std::string &_internal_data() const;

            void _internal_set_data(const std::string &value);

            std::string *_internal_mutable_data();

        public:

            // uint64 sequenceNumber = 2;
            void clear_sequencenumber();

            ::PROTOBUF_NAMESPACE_ID::uint64 sequencenumber() const;

            void set_sequencenumber(::PROTOBUF_NAMESPACE_ID::uint64 value);

        private:
            ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sequencenumber() const;

            void _internal_set_sequencenumber(::PROTOBUF_NAMESPACE_ID::uint64 value);

        public:

            // uint32 flags = 1;
            void clear_flags();

            ::PROTOBUF_NAMESPACE_ID::uint32 flags() const;

            void set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

        private:
            ::PROTOBUF_NAMESPACE_ID::uint32 _internal_flags() const;

            void _internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);

        public:

            // @@protoc_insertion_point(class_scope:stms.proto.Packet)
        private:
            class _Internal;

            ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
            ::PROTOBUF_NAMESPACE_ID::uint64 sequencenumber_;
            ::PROTOBUF_NAMESPACE_ID::uint32 flags_;
            mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
            friend struct ::TableStruct_packet_2eproto;
        };
// ===================================================================


// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Packet

// uint32 flags = 1;
        inline void Packet::clear_flags() {
            flags_ = 0u;
        }

        inline ::PROTOBUF_NAMESPACE_ID::uint32 Packet::_internal_flags() const {
            return flags_;
        }

        inline ::PROTOBUF_NAMESPACE_ID::uint32 Packet::flags() const {
            // @@protoc_insertion_point(field_get:stms.proto.Packet.flags)
            return _internal_flags();
        }

        inline void Packet::_internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {

            flags_ = value;
        }

        inline void Packet::set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
            _internal_set_flags(value);
            // @@protoc_insertion_point(field_set:stms.proto.Packet.flags)
        }

// uint64 sequenceNumber = 2;
        inline void Packet::clear_sequencenumber() {
            sequencenumber_ = PROTOBUF_ULONGLONG(0);
        }

        inline ::PROTOBUF_NAMESPACE_ID::uint64 Packet::_internal_sequencenumber() const {
            return sequencenumber_;
        }

        inline ::PROTOBUF_NAMESPACE_ID::uint64 Packet::sequencenumber() const {
            // @@protoc_insertion_point(field_get:stms.proto.Packet.sequenceNumber)
            return _internal_sequencenumber();
        }

        inline void Packet::_internal_set_sequencenumber(::PROTOBUF_NAMESPACE_ID::uint64 value) {

            sequencenumber_ = value;
        }

        inline void Packet::set_sequencenumber(::PROTOBUF_NAMESPACE_ID::uint64 value) {
            _internal_set_sequencenumber(value);
            // @@protoc_insertion_point(field_set:stms.proto.Packet.sequenceNumber)
        }

// bytes data = 3;
        inline void Packet::clear_data() {
            data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        }

        inline const std::string &Packet::data() const {
            // @@protoc_insertion_point(field_get:stms.proto.Packet.data)
            return _internal_data();
        }

        inline void Packet::set_data(const std::string &value) {
            _internal_set_data(value);
            // @@protoc_insertion_point(field_set:stms.proto.Packet.data)
        }

        inline std::string *Packet::mutable_data() {
            // @@protoc_insertion_point(field_mutable:stms.proto.Packet.data)
            return _internal_mutable_data();
        }

        inline const std::string &Packet::_internal_data() const {
            return data_.GetNoArena();
        }

        inline void Packet::_internal_set_data(const std::string &value) {

            data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
        }

        inline void Packet::set_data(std::string &&value) {

            data_.SetNoArena(
                    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
            // @@protoc_insertion_point(field_set_rvalue:stms.proto.Packet.data)
        }

        inline void Packet::set_data(const char *value) {
                    GOOGLE_DCHECK(value != nullptr);

            data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
            // @@protoc_insertion_point(field_set_char:stms.proto.Packet.data)
        }

        inline void Packet::set_data(const void *value, size_t size) {

            data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                             ::std::string(reinterpret_cast<const char *>(value), size));
            // @@protoc_insertion_point(field_set_pointer:stms.proto.Packet.data)
        }

        inline std::string *Packet::_internal_mutable_data() {

            return data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        }

        inline std::string *Packet::release_data() {
            // @@protoc_insertion_point(field_release:stms.proto.Packet.data)

            return data_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
        }

        inline void Packet::set_allocated_data(std::string *data) {
            if (data != nullptr) {

            } else {

            }
            data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data);
            // @@protoc_insertion_point(field_set_allocated:stms.proto.Packet.data)
        }

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

    }  // namespace proto
}  // namespace stms

PROTOBUF_NAMESPACE_OPEN

        template<>
        struct is_proto_enum<::stms::proto::Packet_Flags> : ::std::true_type {
        };

        template<>
        inline const EnumDescriptor *GetEnumDescriptor<::stms::proto::Packet_Flags>() {
            return ::stms::proto::Packet_Flags_descriptor();
        }

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>

#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_packet_2eproto
